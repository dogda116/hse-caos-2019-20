# 02-stdio

[Подробное изложение](https://github.com/hseos/hseos-course/blob/master/2018/02-stdio/README.md)  

```c
#include <stdio.h>

int	getchar(void);		// equivalent to getc(stdin) 
int	getc(FILE *);		// possibly MACRO, equivalent to fgetc() 
int	fgetc(FILE *);

int putchar(int);		// equivalent to putc(c,stdout).
int putc(int, FILE *);	// possibly MACRO, equivalent to fputc()
int fputc(int, FILE *);

char c = getchar();  // НЕПРАВИЛЬНО!
int c = getchar();   // ПРАВИЛЬНО
```

## Форматированный ввод-вывод

### Форматированный вывод
```c
#include <stdio.h>

int printf(const char *format, ...); 
int fprintf(FILE *stream, const char *format, ...);	
int snprintf(char *s, size_t n, const char *format, ...);
int sprintf(char *s, const char *format, ...);
```

### Форматированный ввод
```c
#include <stdio.h>

int scanf(const char *format, ... );
int fscanf(FILE *stream, const char *format, ... );	
int sscanf(const char *s, const char *format, ... );
```
[Описание форматов](http://www.cplusplus.com/reference/cstdio/printf/)

## Файловый ввод-вывод
```c
#include <stdio.h>

FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);
```
Функция `fopen` открывает файл с именем, указанным в первом аргументе, и связывает с этим файлом поток. В качестве `mode` пользователь может задать режим открытия файла (обязательно один из вариантов):

* `r` - открытие файла на чтение.
* `w` - открытие файла на запись, при этом если файл существовал, то содержимое его удаляется (т.е. обнуляется длина файла), если же файл не существовал, то он создается.
* `a` - открытие файла на запись в конец; если файл не существовал, он создается.
* `r+` - открытие на чтение и запись.
* `w+` - открытие на чтение и запись с обнулением длины существующего файла или созданием нового файла.
* `a+` - открытие на чтение и запись в конец файла, если файл не существовал, он создается.

# 03-integers
[Подробное изложение](https://github.com/hseos/hseos-course/blob/master/2018/03-integers/README.md)  

## Типы фиксированной битности
```c
#include <stdint.h>
#include <inttypes.h>

int64_t val = 69;
printf("Result is %" PRId64 "\n", val);
```

## Переполнение
[Встроенные в gcc функции](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html)
```c
int value1, value2, result;
// как-то считываем value1, value2
if (__builtin_add_overflow(value1, value2, &result)) {
    // в эту ветку попадаем в случае переполнения
    fprintf(stderr, "too bad\n");
} else {
    // а в эту ветку попадаем при нормальном выполнении
    // в этому случае переменная result содержит результат сложения
}
```

# 04-floating-point
[Лекция](https://github.com/hseos/hseos-course/blob/master/2017/00-lectures/03-floats/03-floats.pdf)  
[Классификация](http://steve.hollasch.net/cgindex/coding/ieeefloat.html)
```c
FPClass fpclassf(float value, int *psign) {
    /* wikipedia.org/wiki/Число_одинарной_точности */
    union {
        float    fl;
        uint32_t bits;
    } f;
    f.fl = value;
    
    uint32_t sign = (f.bits >> 31) ? 1 : 0;
    uint32_t exponent = (f.bits >> 23) & 0xff; // aka order
    uint32_t fraction = f.bits & 0x7fffff; // aka mantissa
    
    /* Summary table at steve.hollasch.net/cgindex/coding/ieeefloat.html */
    if (exponent == 0xff && fraction != 0) {
        *psign = 0;
        return FFP_NAN;
    }
    
    *psign = (int) sign;
    
    if (exponent == 0xff && fraction == 0) {
        return FFP_INF;
    }
    
    if (exponent == 0 && fraction == 0) {
        return FFP_ZERO;
    }
    
    if (exponent == 0 && fraction != 0) {
        return FFP_DENORMALIZED;
    }
    
    return FFP_NORMALIZED;
}
```

# 05-arrays
[Подробное изложение](https://github.com/hseos/hseos-course/blob/master/2018/05-arrays/README.md)  

## Массивы

Массив в Си/Си++ - это **непрерывная** область памяти, в которой подряд хранятся элементы одного типа.

```c
int arr1[16];
```

Размер массива равен произведению размера одного элемента на количество элементов. То есть
`sizeof(arr1) = 16 * sizeof(int)`.

## Указатели

Пусть дан массив некоторого типа `T` с количеством элементов `C`:
```c
T arr[C];
```

Арифметические операции над указателями определены в терминах операций над индексами массива.

Само по себе имя массива `arr`, использованное в выражении, неявно преобразовывается в указатель
на начальный элемент массива.
```c
T *p = arr; // то же самое, что *p = &arr[0];
```

Если указатель `p` указывает на элемент с индексом `i` (`p = &arr[i]`), то
`p + j` (прибавление целого числа к указателю) - это то же самое, что
`&arr[i + j]`. Аналогично `p - j` (вычитание целого числа из указателя) - это `&arr[i - j]`.
Если результирующий индекс `i + j` или `i - j` окажется отрицательным или большим `C`,
то результат - undefined behavior. Однако указатель на элемент, непосредственно
следующий за последним элементом массива (`&arr[C]`) допустим, хотя его нельзя
разыменовывать. Эти правила применимы также и к операциям `+=`, `-=`, `++`, `--`
над указателями.

Если указатель `p` указывает на элемент с индексом `i`, а указатель `q` - на элемент
с индексом `j` в том же самом массиве, то
```c
q - p == &arr[j] - &arr[i] = j - i
```
Если указатели указывают на элементы разных массивов - undefined behavior.
Таким образом, разность двух указателей дает разность в терминах количества
элементов массива, расположенных между этими указателями.

Операция обращения по индексу `p[i]` применима к массивам и указателям
и обозначает по определению `*(p + i)`. Если `p` указывает
в середину массива, то вполне допустимы и отрицательные индексы,
при условии, что не происходит выхода за пределы массива.

## Представление строк в Си

Указатель на символ (`char *`) определяет адрес первого
символа в строке. Все остальные символы могут быть получены
инкрементом (эквивалентно - оператором `[]`) этого указателя
на заданное смещение.


```c
static const char * Hello = "Hello, World!";

char first  = *Hello;        // first  = 'H'
char second = *(Hello + 1);  // second = 'e'
char third  = Hello[2];      // third  = 'l'
char last   = Hello[12];     // last   = '!'
char nullval= Hello[13];     // nullval = 0;

```

Ввиду непрерывности размещения строки в памяти, инкремент
указателя на единицу приводит к тому, что он становится
указателем на следующий символ.


```c
static const char * Hello = "Hello";

for ( const char * substring = Hello;
      '\0' != *substring;
      ++substring )
{
   printf("%s\n", substring);
}

/* Вывод на экран:
Hello
ello
llo
lo
o
*/

```

В данном примере исходная строка не изменяется, а на экран
выводятся ее подстроки, получаемые сдвигом указателя на один
символ вперед. Обратите внимание, что переменная цикла
объявлена как `const char*`. В данном случае модификатор
`const` относится не к переменной `substring`, значение
которой изменяется, а к типу данных `char*`, то есть нельзя
изменять содержимое, на которое ссылается указатель.

Если требуется объявить неизменяемость самого указателя,
необходимо писать `const` после символа `*`.


```c
const char * immutable_string    = "You can't modify me!";
char * const immutable_pointer   = "Value can be changed, but pointer not";
const char * const immutable_all = "Everything protected from changes";
```

## Хранение строк

Если определяется массив элементов `char`, который инициализируется строковым литералом,
то указанная строка будет размещена в массиве.

```c
char str[] = "Hello";
```

Размер массива `str` будет равен 6 (5 значащих символов + `\0`-терминатор строки).
В его элементах последовательно будут размещены символы строки.


## Обработка строк

Более универсален вариант, когда в качестве результата работы функции возвращается
строка, буфер под которую выделен в динамической памяти с помощью функций
`malloc` или `realloc`. Например, рассмотрим функцию, выполняющую конкатенацию двух
входных строк:

```c
char *concatenate(const char *str1, const char *str2)
{
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    char *ret = malloc(len1 + len2 + 1); // не забываем \0-байт
    if (ret) {
        memcpy(ret, str1, len1);
        memcpy(ret + len1, str2, len2 + 1);
    }
    return ret;
}
```

Функция предполагает, что аргументы `str1` и `str2` не могут быть указателями NULL.
В аргументах используется ключевое слово `const`, чтобы показать,
что строки не модифицируются функцией `concatenate`.

Функция `malloc` выделяет заданный объем памяти в куче и возвращает указатель на начало.
Если `malloc` не смогла выделить память, возвращается `NULL`.
Выделенная память используется как буфер для хранения строки.

Функция `memcpy(dst,src,size)` копирует `size` байт с места в памяти, на которое указывает
`src` на место, на которое указывает `dst`. **Буфера в памяти не должны перекрываться.**

Такая функция `concatenate` всем хороша. Важно не забыть освободить выделенную память
с помощью функции `free`.

## Чтение строки

Для чтения одной строки из текстового файла используется функция `fgets`.
```c
    char *fgets(char *buf, size_t size, FILE *fin);
```

Функция возвращает `NULL` при ошибке чтения или достижении конца файла.
В противном случае функция возвращает указатель `buf`.

Функция считывает одну строку текста из файла `fin`.
Строка текста заканчивается либо символом '\n', либо концом файла,
либо исчерпанием места в буфере `buf`. Если символ \n считан, он помещается в буфер.
В любом случае считывается не более чем size - 1 символ из входного файла.

Функцию допустимо использовать, когда есть ограничение на максимальную длину строки текста
во входном файле.

## Форматное преобразование в строку

Для форматного вывода данных в строку предназначена функция `snprintf`.
```c
    int snprintf(char *buf, size_t size, const char *format, ...);
```

`buf` и `size` задают буфер для формирования строки. `snprintf` записывает
в буфер не более чем `size` - 1 символ, всегда записывая \0 в конце.
В любом случае функция `snprintf` возвращает столько символов, сколько было
бы записано в выходной поток, если бы размер буфера `buf` был неограниченным.

Пример использования функции `snprintf`.

```c
size_t concatenate(char *buf, size_t size, const char *str1, const char *str2)
{
    return snprintf(buf, size, "%s%s", str1, str2);
}
```

## Инициализация выделенной памяти

В заголовочном файле `<string.h>` объявлена одна очень
полезная функция:

```c
void *memset(void *s, int c, size_t n)
```
заполняет массив из `n` байт, который находится по адресу `s`
**однобайтными** значениями `c` (от `0` до `0xFF`). Возвращает
указатель `s`.

Тип параметра `int c` сохраняется по историческим причинам,
на самом деле переданное значение преобразуется к
`unsigned char`.

Эту функцию можно (и нужно) вызывать после выделения памяти
для массива или буфера, иначе с большой вероятностью,
выделенная память будет содержать какие-то случайные значения.

## Динамическое выделение памяти

Функции динамического выделения и освобождения памяти определены
в заголовочном файле `<stdlib.h>`.

* `void* malloc(size_t n_bytes)` - выделяет память для
 хранения `n_bytes` байт, возвращает нетипизированный
 указатель на выделенную область

* `void free(void *pointer)` - освобождает память,
выделенную ранее функцией `malloc`

Функция `realloc` позволяет изменить размер уже выделенного блока:
```c
void *realloc(void *oldptr, size_t newsize);
```
размер выделенного блока можно как увеличивать, так и уменьшать.
Функция старается, но не гарантирует, чтобы блок памяти остался по тому же
адресу. Поэтому расширение размера может перенести данные на другой адрес.

Функция `realloc` является основой для реализации *расширяемых массивов*
(в C++ им соответствует шаблонный класс `vector`).

В расширяемом массиве для каждого массива хранятся три переменных:
`data` - указатель на массив, `size` - число элементов, хранящихся в массиве,
`reserved` - число элементов, под которые выделена память.

Начальный размер расширяемого массива может быть нулевым, а может быть
равным, например, 32 байта.

```c
    int    *data;
    size_t  size = 0;
    size_t  reserved = 32 / sizeof(*data);
    data = malloc(reserved * sizeof(*data));
```

Если при добавлении элемента в массив места в нем не осталось,
память под него перевыделяется:
```c
    if (size == reserved) {
        data = realloc(data, (reserved *= 2) * sizeof(*data));
    }
    data[size++] = newvalue;
```

# 06-pointers, 07-function-pointers
[Подробное изложение](https://github.com/hseos/hseos-course/blob/master/2018/07-function-pointers/README.md)

# 08-asm1
