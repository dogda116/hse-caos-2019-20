# Problem kr03-1: КР 3-1

Напишите подпрограмму `process`, которая вычисляет выражение
A * X * X - 5 * B * X + 2 * C
числа A, B, C — это переменные, определенные вами в вашей единице компиляции, X передается в регистре %edx, и результат возвращается 
в регистре %edx.

Все входные переменные и результат — 32-битные беззнаковые числа. Все вычисления ведутся с 32-битными беззнаковыми числами, 
переполнение игнорируется (то есть в качестве результата всегда берутся младшие 32 бита).

Соблюдайте правила использования регистров в стандартном соглашении о вызовах.

Например, при A == 1, B == 2, C == 3, X == 4 результат вычислений равен 4294967278.

# Problem kr03-2: КР 3-2
Напишите подпрограмму процесс (имя в кодировке UTF-8), удовлетворяющую следующему прототипу на Си:
```c
int процесс(const signed char *a, int b, signed char *c);
```
Подпрограмма вычисляет значение выражения b * 3 - *a * 2. Если выражение b * 3 непредставимо 32-битным знаковым типом, подпрограмма возвращает результат 1 и значение по указателю c не изменяется. Иначе если выражение *a * 2 непредставимо 8-битным знаковым типом, подпрограмма возвращает результат 2 и значение по указателю c не изменяется. Иначе если выражение b * 3 - *a * 2 непредставимо 8-битным знаковым типом, подпрограмма возвращает результат 3 и значение по указателю c не изменяется. Иначе подпрограмма возвращает результат 0 и по указателю c записывается значение вычисленного выражения.

Можете предполагать, что указатели a и c не равны NULL.

Подпрограмма должна соблюдать стандартные соглашения о вызовах. Должен создаваться стековый фрейм.

Например, при a == 10 и b == 5 по указателю c должно быть записано -5, а функция должна вернуть 0.

# Problem kr03-3: КР 3-3
Напишите подпрограмму `exchange`. В регистре %eax подпрограмме передается адрес начала массива чисел типа uint32_t, в регистре %edx передается количество чисел (всегда больше 0). Пусть массив называется a, количество элементов в нем n. Для всех пар чисел, симметрично расположенных относительно середины массива, то есть для пар (a[0], a[n-1]), (a[1], a[n-2])... переставьте числа в парах таким образом, чтобы первое число в паре всегда было не больше второго числа в паре. В регистре %ecx верните количество выполненных перестановок.

Например, если дан массив {5, 1, 2, 3}, результатом его обработки должен быть массив {3, 1, 2, 5}, и в регистре ecx должно быть возвращено число 1.

Соблюдайте требования по сохранению/восстановлению регистров.

# Problem kr03-4: КР 3-4
Элемент списка определяется следующим образом:
```c
struct Elem
{
    struct Elem *next;
    char *str;
};
```
str указывает на строку, размещенную в области динамической памяти.

Напишите функцию на Си:
```c
struct Elem *dup_elem(struct Elem *head);
```
Если у некоторого элемента p в строке p->str записано текстовое десятичное представление 32-битного целого числа x, причем пробелы 
в начале допускаются, а в конце - нет, то перед каждым таким элементом в список добавляется новый элемент, у которого в строке 
записано десятичное представление числа x + 1, если оно представимо 32-битным целым знаковым значением. В текстовом представлении 
числа в новом элементе списка не должно быть пробелов, лишних знаков плюс и нулей.

Функция должна вернуть указатель на первый элемент получившегося списка.

Например, если в списке хранились строки "10" "5x" "alpha" " -03", то в результирующем списке должны храниться 
строки "11" "10" "5x" "alpha" "-2" " -03".

В сдаваемой на проверку программе должно присутствовать определение структуры struct Elem.

# Problem kr03-5: КР 3-5
None
