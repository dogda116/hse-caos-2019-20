# Problem kr05-1: КР 5-1

В аргументе командной строки задается путь к бинарному файлу. 
В указанном бинарном файле поменяйте местами первые sizeof(int) байтов файла и последние sizeof(int) байтов файла.


Если по каким-либо причинам это сделать невозможно (например, файл имеет недостаточный размер (меньше чем два sizeof(int)), ошибка выполнения системного вызова),
программа не должна модифицировать указанный файл, а завершиться с кодом завершения 1.  

Используйте POSIX API для работы с файлами (read/write и т. д.).

# Problem kr05-2: КР 5-2
В аргументах командной строки программе передается два числа: год григорианского календаря и месяц (от 1 до 12).
На стандартный поток вывода напечатайте количество рабочих часов в указанном месяце указанного года.
Рабочими днями считаются дни с понедельника по пятницу. С понедельника по четверг продолжительность
рабочего дня - 8 часов, а в пятницу - 6 часов.  

Например, в октябре 2018 года по этой методике было 176 рабочих часов.  

Гарантируется, что время в формате Unix всех дней месяца полностью представимы 32-битным типом time_t.

# Problem kr05-3: КР 5-3
Дано описание структуры:
```c
struct Context
{
    uintptr_t addr;
    size_t size;
    int *out;
};
```
Напишите на ассемблере функцию
```c
void countrec(struct Context *cntx);
```
Функция по адресу в поле out запишет количество рекурсивных вызовов некоторой функции,
которая имеет адрес начала addr и размер в секции кода size.
Точнее, по адресу в поле out нужно записать количество стековых фреймов, адрес возврата в которых
соответствует указанной функции.  

Все функции компилируются с поддержкой стековых фреймов (-fno-omit-frame-pointer).

# Problem kr05-4: КР 5-4
На стандартный поток ввода программы подается последовательность целых чисел типа unsigned
в текстовом виде.  

В файл, имя которого указано в аргументе командной строки,
запишите эту последовательность чисел в бинарном виде. Числа должны записываться
в формате Big Endian (старший байт первым).  

Выходной файл должен быть создан с правами только на чтение и запись только для владельца,
если он не существовал.  

Для работы с выходным файлом используйте POSIX API. Для записи одного числа используйте один системный вызов write.
Не используйте системные функции преобразования, например, htonl и аналогичные. Не используйте в программе implementation-defined особенности платформы, например union, приведение указателей разных типов друг к другу и т. п. Не используйте условную компиляцию.
Например, если программа запущена следующим образом:
```
./solution out.bin
```
И на стандартном потоке ввода введено:
```
1 2 120 2000000000
```
То должен быть создан файл `out.bin`, и команда `hexdump -C out.bin` выдаст следующий результат:
```
00000000  00 00 00 01 00 00 00 02  00 00 00 78 77 35 94 00  |...........xw5..|
00000010
```

# Problem kr05-5: КР 5-5
Мииихаил и Игоооорь играют в чате в следующую игру.  

Один игрок отправляет другому файл, который должен быть обработан
по специальным правилам и переслан судье Petrovi4.
Выигрывает тот игрок, который переслал судье файл, контрольная сумма
которого делится нацело на константу G.  

Вам нужно написать программу, обрабатывающую файл по правилам игры. Пересылать файл или проверять его контрольную сумму не требуется.
В аргументах командной строки задается путь к бинарному файлу, содержащему целые знаковые числа типа long long, записанные в порядке байт хоста
(компьютера, на котором исполняется программа). В файле найдите минимальное число и поменяйте его знак. Если минимальное число в файле встречается несколько раз,
поменяйте знак только у первого по порядку минимального числа. При вычислениях предполагайте неограниченную битность, но в качестве результата оставьте младшие 64 бита.
Для работы с файлом используйте POSIX API.  

Допускается только один проход по файлу, но бинарный файл
является файлом произвольного доступа.  

На 32-битных системах компилируйте вашу программу с опцией -D_FILE_OFFSET_BITS=64. Не допускайте в программе undefined behavior.
Например, если дан входной бинарный файл `input.bin`, результатом обработки его должен быть файл распечатка содержимого которого
показана ниже.
```
hexdump -C input.bin
00000000  03 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|
00000010  04 00 00 00 00 00 00 00                           |........|
00000018
```
