# Problem kr04-1: КР 4-1

Напишите функцию **forward$args** (имя содержит знак $), которая принимает аргументы
```c
(void *that, int v2, long long v3, float v4)
```
причем аргумент that передается в регистре ecx, а остальные аргументы — на стеке в соответствии со стандартным соглашением о вызовах x86. 
Функция возвращает значение типа int.

Функция должна вызвать функцию process, которой передать аргументы
```c
(void *that, long long v2, float v4, unsigned v3)
```
передавая все параметры на стеке в соответствии со стандартным соглашением о вызовах x86. Имена параметров функций forward$args и 
process соответствуют друг другу, то есть параметр с соответствующим именем у forward$args должен передаваться на соответствующем 
месте у process. При необходимости должно выполняться преобразование типов параметров по правилам языка Си.

Функция forward$args должна вернуть результат функции process с обратным знаком.

Поддерживайте 16-байтовое выравнивание стека. Изначально (перед вызовом forward$args) стек корректен. Для преобразований типа может 
быть полезны инструкции вида "Convert Doubleword to Quadword", существующие на x86. Функция forward$args должна создавать свой стековый 
фрейм.

# Problem kr04-2: КР 4-2
Дан тип структуры:
```c
struct S
{
    struct S *next;
    int z[2];
    int y[2];
};
```
На языке ассемблера x86 напишите подпрограмму process с прототипом:
```c
uint32_t process(struct S *p);
```
Подпрограмма принимает свой аргумент в регистре eax и выполняет вычисления:
```c
long long t = (long long) p->z[0] * (long long) p->y[1] + (long long) p->z[1] * (long long) p->y[0];
```
Если значение t отрицательно, то process должен вернуть (unsigned)-1. В противном случае вычисляется t / 16. 
Если значение t непредставимо в типе uint32_t, то process должен вернуть (unsigned)-1. В противном случае process возвращает t / 16.

При вычислении t переполнение можно не проверять.

# Problem kr04-3: КР 4-3
На языке ассемблера напишите подпрограмму **mysin** со следующим прототипом (на Си):
```c
double mysin(double x);
```
Аргумент x подпрограмма принимает в регистре xmm7, и результат работы подпрограмма возвращает в xmm7.

Подпрограмма должна вычислить выражение sin(x) при x на отрезке [-1;1].

Для вычислений используйте разложение в ряд Маклорена функции. Суммирование ведите до тех пор, пока сумма не перестанет 
изменяться. Учтите, что очередной член суммы Si проще получить из Si-1, чем вычислять с нуля.

Должен использоваться стандартный пролог и эпилог функции. Запрещается использовать стандартные функции. Для вычислений используйте SSE.

# Problem kr04-4: КР 4-4
Напишите функцию **shrbe** со следующим прототипом на Си:
```c
void shrbe(size_t n, unsigned char *p, int cnt);
```
Параметры передаются в регистрах eax, edx и ecx соответственно.

Гарантируется, что p не равен NULL. Параметр cnt больше 0 и меньше 8. Параметр n больше 0.

Функция shrbe выполняет сдвиг вправо на cnt беззнакового целого числа длины n байт, хранящегося по указателю p в порядке 
Big-Endian. Сдвинутое число остается на своем месте и имеет такой же размер.

Например, если число в памяти представляется двумя байтами { 0x24, 0x85 } и выполняется его сдвиг на 6, должен быть получен 
результат { 0x00, 0x92 }.

# Problem kr04-5: КР 4-5
None
