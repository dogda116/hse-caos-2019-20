# Problem kr02-1: КР 2-1

В аргументах командной строки передаются числа в восьмеричной системе счисления в диапазоне от 1 до 64 (десятичное), 
разделенные символом ‘,’ (запятая). Рассматривайте эти числа как элементы множества в котором каждое число представляется одним битом, 
представьте множество в виде 64-битного беззнакового числа и на стандартный поток вывода выведите это число в шестнадцатеричном виде.

## Examples
###### Input
```
./solution 1,7,100,2,7,
```
###### Output
```
‭8000000000000043‬
```
###### Input
```
./solution 1,11,14,13
```
###### Output
```
d01
```
###### Input
```
./solution ,
```
###### Output
```
0
```
###### Input
```
./solution
```
###### Output
```
0
```

# Problem kr02-2: КР 2-2
Напишите функцию process со следующим прототипом:
```
size_t process_2(const char *str, const char *range);
```
Второй аргумент (range) - это диапазон символов: два символа, разделенные знаком - (минус). Например, “a-z”. Первый аргумент - это строка. Функция должна вернуть количество первых символов в строке str (то есть длину префикса строки), которые попадают в указанный диапазон.

В диапазоне символов первый символ не больше второго.

Можете предполагать, что символы в кодировке занимают один байт.

## Examples
```
process_2("abcdccc", "a-c") == 3
```

# Problem kr02-3: КР 2-3
Элемент односвязного списка определен следующим образом:
```
struct Elem
{
    struct Elem *next;
    char *str;
};
```
Список упорядочен по лексикографическому возрастанию и не содержит равных строк.

Определите функцию
```
struct Elem *process_3(struct Elem *head, char *str, int precount);
```
Если строка str уже находится в списке, функция не выполняет никаких действий. В этом случае возвращается значене head.

В противном случае на свое место списка вставляется новый элемент с копией строки str, и удаляются с освобождением памяти precount элементов списка, расположенные перед добавленным, если они существуют.Если перед вставленным элементом находится меньше precount элементов, удаляются все, таким образом, вставленный элемент окажется новой головой списка.

Функция возвращает указатель на голову модифицированного списка.

# Problem kr02-4: КР 1-4
"Рваная" матрица вещественных чисел представлена указателем типа double *** следующим образом: матрица размещается по строкам, каждая элемент массива строк - это указатель на массив указателей на double (то есть каждая строка массива имеет тип double **). Каждый элемент строки - указатель на double. Массив строк завершается нулевым указателем, каждая строка завершается нулевым указателем. Строки могут иметь разную длину.

Например, рассмотрим матрицу arr:
```
1 2 3
4 5 6 7
8
```
Она представляется в виде массива из трех указателей, за которым следует элемент NULL.
```
[0] -> {1}, {2}, {3}, NULL
[1] -> {4}, {5}, {6}, {7}, NULL
[2] -> {8}, NULL
[3] -> NULL
```
То есть элемент arr[0] - это указатель на массив из 3 указателей, за которыми идет нулевой указатель. 
Элемент arr[0][1] - это указатель на значение 1 типа double. Нулевой указатель не может встретиться в середине массива значений.

Напишите функцию, которая транспонирует массив массивов. Функция должна вернуть новый транспонированный массив. 
Сами числа double должны быть скопированы.
```
double ***transpose(double ***arr);
```
При этом, если в результате транспонирования в середине строки появляются нулевые указатели, они должны заменяться на указатель на 
вещественное значение 0 (каждый раз новый).

Например, матрица:
```
1 2 3
4 5 6 7
8
```
транспонируется в
```
1 4 8
2 5
3 6
0 7
```
Матрица
```
1
2 3
4 5 6
```
транспонируется в
```
1 2 4
0 3 5
0 0 6
```

# Problem kr02-5: КР 2-5
Пусть дана строка S длины N. Символы строки нумеруются, как обычно, от 0, то есть S[0] ... S[N−1].

Преобразование Барроуза-Уилера (Burrows-Wheeler Transform) над строкой S можно определить следующим образом. 
Добавим к строке специальный символ-терминатор, который обозначим знаком '#'. Этот символ лексикографически больше всех допустимых 
символов. Рассмотрим все возможные циклические сдвиги данной строки, запишем их в лексикографическом порядке одну под другой. 
Получим матрицу размера N+1 × N+1. Возьмём в этой матрице последний столбец, он и будет искомой строкой. Например, рассмотрим 
строку бананарама. Матрица сдвигов:
```
бананарама#
ананарама#б
нанарама#ба
анарама#бан
нарама#бана
арама#банан
рама#банана
ама#бананар
ма#бананара
а#бананарам
#бананарама
```
Сортируем ее лексикографически:
```
ама#бананар
ананарама#б
анарама#бан
арама#банан
а#бананарам
бананарама#
ма#бананара
нанарама#ба
нарама#бана
рама#банана
#бананарама
```
В результате получим строку рбннм#ааааа.

На стандартном потоке ввода подается текст. Все пробельные символы в тексте игнорируются. К оставшемуся тексту применяется описанное выше преобразование, его результат выводится на стандартный поток вывода, причем специальный символ терминатор выводится как '#'.

Используйте wide character API
## Examples
###### Input
```
банан
      арама
```
###### Output
```
рбннм#ааааа
```
